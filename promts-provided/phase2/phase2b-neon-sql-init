/specify

Feature: Persistent task storage (SQLModel + Neon Postgres)

User journeys
1.1 Start backend with a real database connection
1.2 Create a task in the database
1.3 Fetch a task from the database
1.4 List tasks from the database

Acceptance criteria
2.1 Backend uses SQLModel as the ORM
2.2 Database is Neon Serverless PostgreSQL (Postgres connection string via env var, e.g. DATABASE_URL)
2.3 A Task model exists as a SQLModel table with at least:
2.3.1 id (primary key, auto)
2.3.2 title (required, non-empty)
2.3.3 description (optional)
2.3.4 completed (boolean, default false)
2.3.5 created_at (timestamp)
2.4 On app startup, the database connection initializes successfully
2.5 Migrations or table creation approach is defined (simple SQLModel.metadata.create_all is OK for now)
2.6 Core DB operations are implemented in a testable service/repository layer (not inside route handlers)

Success metrics
3.1 pytest tests pass for DB operations (create/get/list)
3.2 Coverage ≥80% for backend code touched in this step
3.3 A local run can connect to Neon and perform a real insert + read without errors

/prompts:sp.plan

Create: architecture sketch, interfaces, data model, error handling, requirements.
Decisions needing: list important choices with options and tradeoffs.
Testing strategy: unit + integration tests based on acceptance criteria.
Technical details:
- Use a simple, functional approach where it makes sense
- Use Neon Serverless PostgreSQL
- Use backend SQLModel as the ORM
- Follow TDD: write tests first, then implementation
- Organize code and tests according to your constitution rules

/sp.tasks

Break plan into small tasks (T001..), each ≤ 3 minutes, testable, reversible.
Add dependencies between tasks; group into phases; mark deliverables per task. Group tasks by operations and for each operation like add use TDD approach so RED Tests, Green Tests and Refactor. After each group we pause for human review and on approval commit to github.

Focus on:
- TDD approach (tests first for each operation)
- Small, step-by-step implementation
- Clear task dependencies
- Easy to undo changes

/sp.implement

Rules: tests first, smallest diff, keep public API stable within a phase.
After each task: run tests, update checklist, note deltas to spec if needed Mark completed tasks in tasks.md

********* to test it *********

Manual steps to validate against Neon

  1. Export your Neon credentials:

     export UV_PYTHON=python3.13
     export UV_CACHE_DIR=.uv-cache
     export DATABASE_URL="postgresql://neondb_owner:npg_xnOe7Ta9oWIt@ep-autumn-violet-a43cnvj3-pooler.us-east-1.aws.neon.tech/neondb?
  sslmode=require&channel_binding=require"
     export RUN_DB_TESTS=1
  2. Run the service-level CRUD tests:

     uv run pytest --maxfail=1 tests/unit/test_task_service.py tests/integration/test_task_crud.py
  3. Run the full suite plus coverage:

     uv run pytest --cov=src --cov-report=term-missing
  4. Start the app and hit /health:

     uv run uvicorn src.main:app --reload --port 8000
     curl http://127.0.0.1:8000/health
     Successful boot + HTTP 200 imply the Neon connection works.
